/*******************************************************************************
 * Copyright (c) 2021, Intecs Solutions Spa 
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *  
 *   Contributors:
 *   Felicien Ihirwe
 *   Initial API and implementation and/or initial documentation
 *******************************************************************************/
/**
 */


pre{
	"Running Analysis -------------------------".println();
	var mapping : Sequence ;
	var ftas : Sequence ;
	var parents : Sequence;
	var events : Sequence;
	var count : Integer;
	count=0;
	mapping = emftanew!FTAModel.allInstances();
	for(ft in mapping){
		if(ft.events.size()>1){
			var fta = new emfta!FTAModel;
			fta.name = ft.name;
			ftas.add(fta);
		}
	}
}

rule topEvent2FTA
transform ftSource : emftanew!FTAModel
to evTarget : emfta!Event{
	var firstelement : Boolean = true;
	for(ftTarget in ftas){
		if(firstelement = true){
			for(evSource in ftSource.events){
				if(ftTarget.name = "Fault Tree of "+evSource.name){
					var nevEv= new emfta!Event;
					nevEv.name=evSource.name;
					if(evSource.gate.events.size()>1){
						nevEv= AssignNewType(evSource,nevEv);
						nevEv.gate=getGate(evSource.description);
						nevEv.probability=evSource.probability;
						ftTarget.events.add(nevEv);
						firstelement=false;
						generateFollowings(evSource,nevEv,ftTarget);
					}
					else if(evSource.gate.events.size()=1){
							getTheNextEvenWithOneEvent(evSource,nevEv,ftTarget,firstelement);
					}
				}
			}
		}
		"1------> Cleaning fault tree on ".println();
		ftTarget.name.println();
		cleanTree(ftTarget);
		"------> Calculating probailities ".println();
		ftTarget.name.println();
		for(event in ftTarget.events){
			if("Fault Tree of "+event.name=ftTarget.name){
				
				if (event.probability=0){
					var eventProb=1;
	//				get the gate atached to it (in cas it is a OR gate
					if(event.gate.type.name="OR"){
	//					check all following events and check if they are among the system's events
						for(ev in event.gate.events){
	//						sometimes these attached event includes the original events that why it need to be excluded
							if(not(ev.name = event.name) and ftTarget.events.contains(ev)){
								if(ev.type.name="Intermediate"){
									var p=getProbability(ev,event.gate,ftTarget).asDouble();
									eventProb=eventProb*(1-p);
	
								}			
								else{
									eventProb=eventProb*(1-ev.probability);
								}
							}
	
						}
						event.probability=(1-eventProb).asDouble();
					}
					else if(event.gate.type.name="AND"){
						for(ev in event.gate.events){
							if(not(ev.name = event.name) and ftTarget.events.contains(ev)){
								if(ev.type.name="Intermediate"){
									var p=getProbability(ev,event.gate,ftTarget).asDouble();
									eventProb=eventProb*p;
								}			
								else{
									eventProb=eventProb*(ev.probability);
								}
							}
	
						}
						event.probability=(eventProb).asDouble();
					}
				}
			}
		}
		
		cleanGates(ftTarget);
	}
}
operation getTheNextEvenWithOneEvent(evSource: emftanew!Event, nevEv : emfta!Event, ftTarget : emfta!FTAModel,firstelement : Boolean) : Sequence{
	for(event in evSource.gate.events){
		if(event.type.name="Basic"){
			if(firstelement=true){
				nevEv= AssignNewType(evSource,nevEv);
				nevEv.gate=getGate(evSource.description);
				nevEv.description=evSource.description;
				nevEv.probability=evSource.probability;
				ftTarget.events.add(nevEv);
				firstelement=false;
				var localEv= new emfta!Event;
				localEv.name=event.name;
				localEv.type= emfta!EventType#Basic;
				localEv.description=event.description;
				localEv.probability=event.probability;
				nevEv.gate.events.add(localEv);
				ftTarget.events.add(localEv);
				parents.add(nevEv);	
			}
			else{
				firstelement=false;
				nevEv.name=event.name;
				nevEv.type= emfta!EventType#Basic;
				nevEv.description=event.description;
				nevEv.probability=event.probability;
				ftTarget.events.add(nevEv);
				parents.add(nevEv);			
			}
		}
		else if(event.type.name="External"){
			if(firstelement=true){
				nevEv= AssignNewType(evSource,nevEv);
				nevEv.gate=getGate(evSource.description);
				nevEv.description=evSource.description;
				nevEv.probability=evSource.probability;
				ftTarget.events.add(nevEv);
				firstelement=false;
				var localEv= new emfta!Event;
				localEv.name=event.name;
				localEv.type= emfta!EventType#External;
				localEv.description=event.description;
				localEv.probability=event.probability;
				nevEv.gate.events.add(localEv);
				ftTarget.events.add(localEv);
				parents.add(nevEv);	
			}
			else{
				firstelement=false;
				nevEv.name=event.name;
				nevEv.type= emfta!EventType#External;
				nevEv.description=event.description;
				nevEv.probability=event.probability;
				ftTarget.events.add(nevEv);
				parents.add(nevEv);
			}
		}
		else if(event.type.name="Intermediate"){
			if(event.description.split("_").get(1)=evSource.description.split("_").get(1)){
				if(event.gate.events.size()>1){
					
					if(firstelement=false){
						nevEv.name=evSource.name;
					}
					nevEv= AssignNewType(event,nevEv);
					nevEv.gate=getGate(event.description);
					nevEv.description=event.description;
					nevEv.probability=event.probability;
					ftTarget.events.add(nevEv);
					firstelement=false;
					generateFollowings(event,nevEv,ftTarget);
				}
				else if(event.gate.events.size()=1){
					getTheNextEvenWithOneEvent(event,nevEv,ftTarget,firstelement);
				}
			}
			else{
				//in case the two single events are not the same
				//implement the source and check the next event properties
				nevEv= AssignNewType(evSource,nevEv);
				nevEv.gate=getGate(evSource.description);
				nevEv.description=evSource.description;
				nevEv.probability=evSource.probability;
				ftTarget.events.add(nevEv);
				firstelement=false;
				if(event.gate.events.size()>1){
					// if greater than one and different form source.. implement that
					var localEv= new emfta!Event;
					localEv.name=event.name;
					localEv= AssignNewType(event,localEv);
					localEv.gate=getGate(event.description);
					localEv.description=event.description;
					localEv.probability=event.probability;
					nevEv.gate.events.add(localEv);
					ftTarget.events.add(localEv);
					generateFollowings(event,localEv,ftTarget);
				}
				else if(event.gate.events.size()=1){
					// else implement half and look the next different of many child event
					var localEv= new emfta!Event;
					localEv.name=event.name;
					nevEv.gate.events.add(localEv);
					getTheNextEvenWithOneEvent(event,localEv,ftTarget,firstelement);
				}			
			}	
		}
	}
}

operation generateFollowings(lookEv: emftanew!Event, grobalEv : emfta!Event, ft : emfta!FTAModel) : Sequence{
		for(event in lookEv.gate.events){
				if(event.gate.events.size()>1){
					var localEv= new emfta!Event;
					localEv.name=event.name;
					localEv= AssignNewType(event,localEv);
					localEv.gate=getGate(event.description);
					localEv.description=event.description;
					localEv.probability=event.probability;
					grobalEv.gate.events.add(localEv);
					ft.events.add(localEv);
					generateFollowings(event,localEv,ft);
				}
				else if(event.gate.events.size()=1){
					var localEv= new emfta!Event;
					localEv.name=event.name;
					grobalEv.gate.events.add(localEv);
					getTheNextEvenWithOneEvent(event,localEv,ft,false);					
				}
		}
}
operation getGate(st : String): emfta!Gate{
	var g=new emfta!Gate;
	for (gate in emftanew!Gate.allInstances()){
		if(gate.description = st){
			if(gate.type.name="OR"){
				g.type=emfta!GateType#OR;
			}
			else{
				g.type=emfta!GateType#AND;
			}
			g.description=gate.description;
			for(oldEv in gate.events){
				var evTemp=new emfta!Event;
				evTemp.name=oldEv.name;
				evTemp=AssignNewType(oldEv,evTemp);
				evTemp.description=oldEv.description;
				g.events.add(evTemp);
			}
			g.nbOccurrences=gate.nbOccurrences;
			return g;
		}
	}
}

operation AssignNewType(oldEv: emftanew!Event,evTemp: emfta!Event):emfta!Event{
	if(oldEv.type.name="External"){
		evTemp.type=emfta!EventType#External;
	}
	else if(oldEv.type.name="Basic") {
		evTemp.type=emfta!EventType#Basic;
	}
	else {
		evTemp.type=emfta!EventType#Intermediate;
	}
	return evTemp;
}


operation getProbability(lookEv: emfta!Event, gate : emfta!Gate, ftTarget:emfta!FTAModel) : Any{
	var eProb=1;
	//Same process but here we need to return the lookEV probability
	if(lookEv.gate.type.name="OR"){
		for(ev in lookEv.gate.events){

			if(not(ev.name = lookEv.name) and ftTarget.events.contains(ev)){

				if(ev.type.name="Intermediate"){
					var p=getProbability(ev,lookEv.gate,ftTarget).asDouble();
					eProb=eProb*(1-p);
				}			
				else{
					eProb=eProb*(1-ev.probability);
				}
			}

		}
		lookEv.probability=(1-eProb).asDouble();
		return lookEv.probability;
	}
	else if(lookEv.gate.type.name="AND"){
		for(ev in lookEv.gate.events){
			if(not(ev.name = lookEv.name) and ftTarget.events.contains(ev)){

				if(ev.type.name="Intermediate"){
					var p=getProbability(ev,lookEv.gate,ftTarget).asDouble();
					eProb=eProb*p;
				}			
				else{
					eProb=eProb*(ev.probability);
				}
				
			}

		}
		lookEv.probability=(eProb).asDouble();
		return lookEv.probability;
	}

	return lookEv.probability;
}

operation cleanTree(ftTarget : emfta!FTAModel) : Any{
	var k=0;
	var gates= emfta!Gate.allInstances();
	var toRemove : emfta!Event;
	while(k<gates.size()){
		var gate= gates.at(k);
		
		var i=0;
		var eventsLocal=gate.events;
		while(i<eventsLocal.size()){
			if(not (eventsLocal.at(i).type.name="Intermediate")){
				var name=eventsLocal.at(i).name;
				if(i+1<eventsLocal.size()){
					if(name= eventsLocal.at(i+1).name){
						"---------------=====REMOVED DUPLICATE========---------".println();
						name.println();
						"---------------=============---------".println();
						toRemove= eventsLocal.at(i);
						ftTarget.events.remove(toRemove);
						eventsLocal.remove(eventsLocal.at(i));
						emfta!Event.allInstances().remove(eventsLocal.at(i));
						parents.remove(eventsLocal.at(i));
					}	
				}
			}
			i=i+1;
		}
		k=k+1;
	}	
}

operation cleanGates(ftTarget : emfta!FTAModel) : Any{
	var k=0;
	var gates= emfta!Gate.allInstances();
	var toRemove : emfta!Event;
	while(k<gates.size()){
//		"I'm in-----------------------------";
		var gate= gates.at(k);
			if(gate.events.size()<4){
				gate.type=emfta!GateType#INTERMEDIATE;
				gate.description="";
			}
		k=k+1;
	}	
}
